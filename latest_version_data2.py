# -*- coding: utf-8 -*-
"""latest_version-data2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f-0nJrSSjTCVi6S93jDAX_Cfltqlnmqz
"""

!pip install category_encoders
!pip install shap

import shap
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, roc_curve, roc_auc_score, confusion_matrix, balanced_accuracy_score
import xgboost as xgb
from sklearn.feature_selection import SelectFromModel
from plotnine import *
import plotnine
import sys
import category_encoders as ce

ruta = '/content/drive/MyDrive/Universidades/unaHur/cidia/Pasantias 2022/'
# data y data2
df = pd.read_csv(ruta + 'data2.csv', delimiter = ';')

pd.options.display.max_columns = None
pd.options.display.max_rows = None
pd.set_option("display.max_colwidth", -1)
np.set_printoptions(threshold=sys.maxsize)

df.to_csv('data2.csv')

df.head()

from google.colab import drive
drive.mount('/content/drive')

df.head()

# MAKE THE CLASS BINARY (0 = continues, 1 = dropout)

df['cant_eval_m0'].values[df['cant_eval_m0'].values >= 1] = 2
df['cant_eval_m0'].values[df['cant_eval_m0'].values == 0] = 1
df['cant_eval_m0'].values[df['cant_eval_m0'].values == 2] = 0

# HANDLE NULLS

df['censo_cp'] = df['censo_cp'].fillna('-5')
df['censo_cursada_cp'] = df['censo_cursada_cp'].fillna('-5')
df['email'] = df['email'].fillna('-14')

df.head()

# FORMAT TEXT FIELDS

df['apellido'] = df['apellido'].str.upper()
df['email'] = df ['email'].str.lower()
df['censo_piso'] = df['censo_piso'].str.upper()
df['censo_cursada_piso'] = df['censo_cursada_piso'].str.upper()
df['censo_calle'] = df['censo_calle'].str.upper()
df['censo_cursada_calle'] = df['censo_cursada_calle'].str.upper()
df['censo_barrio'] = df['censo_barrio'].str.upper()
df['censo_cursada_barrio'] = df['censo_cursada_barrio'].str.upper()
df['censo_cursada_localidad_nombre'] = df['censo_cursada_localidad_nombre'].str.upper()
df['censo_localidad_nombre'] = df['censo_localidad_nombre'].str.upper()

df.head()

# # ESTANDARIZAR CANTIDAD HIJOS and CANTIDAD FAMILIA (CONVERTIR EN INT)

#PLOT CANTIDAD DE HIJOS

map = plt.get_cmap('tab20c').colors

x = np.sort(df.censo_cantidad_hijos.unique())
y = df.censo_cantidad_hijos.value_counts()

plt.figure(figsize=(12,9))
plt.bar(x,y, width = 0.2, color = map)
plt.title('CANTIDAD DE HIJOS / ESTUDIANTE', fontsize = 15)
plt.ylabel('CANTIDAD DE ESTUDINATES', fontsize = 12)
plt.xlabel('CANTIDAD DE HIJOS', fontsize = 12)

#PLOT CANTIDAD FAMILIARES

x = np.sort(df.censo_cantidad_familia.unique())
y = df.censo_cantidad_familia.value_counts()

plt.figure(figsize=(12,9))
plt.title('CANTIDAD DE FAMILIARES / ESTUDIANTE', fontsize = 15)
plt.bar(x,y,width = 0.2, color = map)
plt.ylabel('CANTIDAD DE ESTUDIANTES', fontsize = 12)
plt.xlabel('CANTIDAD DE FAMILIARES', fontsize = 12)

# HIST EDAD ANTES DE IMPUTACION

x = df.edad

plt.figure(figsize=(10,7))
plt.title('EDAD DE LOS ESTUDIANTES', fontsize = 15)
plt.hist(x, color = '#7B89C1')
plt.ylabel('CANTIDAD DE ESTUDIANTES', fontsize = 12)
plt.xlabel('EDAD', fontsize = 12)

# HANDLE NOISE IMPUTING THE MEAN AGE

print((df['edad'] >= 90).sum())
print((df['edad'] <= 17).sum())

df['edad'].values[df['edad'].values >= 90] = 31
df['edad'].values[df['edad'].values <= 17] = 31

# HIST AGE DISTRIBUTION

x = df.edad

plt.figure(figsize=(10,7))
plt.hist(x, color = '#7B89C1')
plt.title('EDAD DE LOS ESTUDIANTES', fontsize = 15)
plt.ylabel('CANTIDAD DE ESTUDIANTES', fontsize = 12)
plt.xlabel('EDAD', fontsize = 12)

#HIST PISO ANTES DE LIMPIAR EL CAMPO

x = df['censo_piso'].drop_duplicates().dropna()
y = df.censo_piso.value_counts()

# CLEAN CENSO_PISO & CENSO_CURSADA_PISO

df['censo_piso'] = df['censo_piso'].replace(['-','---','--','_','.','N/A','\\n','|','__','/','X','NIN','XXX','S/N','...','N','NAD'], ['NO', 'NO', 'NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO'])
df['censo_piso'] = df['censo_piso'].replace(['0','P.B','PB-','-PB','P B','BAJ','PB.','P:B'], ['PB', 'PB', 'PB','PB','PB','PB','PB','PB'])
df['censo_piso'] = df['censo_piso'].replace(['M40','PL','CAS','EP','Q','FDO','OO','M.A','P','PAL','FON','MAN','FRE','PID','P V','PBA','PIS','O.B', 'B','O','SI','-1','M19','86','59','DPT','M31','A','M5','F','D','80','I','340','M37','H','M 3','94','C63','M3','C','M49','MZ6','280','105','M7','53','205','92','B2','PLA','99','M65','100','#NAME?','2:00 AM','4:00 AM','1:00 AM',r'\N',np.NaN], ['OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO', 'OTRO', 'OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO', 'OTRO', 'OTRO', 'OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO', 'OTRO','OTRO','OTRO', 'OTRO', 'OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO'])
df['censo_piso'] = df['censo_piso'].replace(['P.A','P/A','PH ','-PH','FDO','OO','M.A','P','PAL','FON','MAN','FRE','PID','P V','PBA','PIS','O.B', 'B','O','SI','-1','M19','86','59','DPT','M31','A','M5','F','D','80','I','340','M37','H','M 3','94','C63','M3','C','M49','MZ6','280','105','M7','53','205','92','B2','PLA','99','M65','100'], ['PA', 'PA', 'PH','PH','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO', 'OTRO', 'OTRO', 'OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO', 'OTRO','OTRO','OTRO', 'OTRO', 'OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO'])
df['censo_piso'] = df['censo_piso'].replace(['1B','1°','1RO','1ER','1º','PRI','-1°','1C','1 A','1A','1A','1P','P1','1R.','Nª1','2DO','5TO','2B','4TO','6TO','2°','2 A', '3º','2A','9°','5°','2º','4 A'], ['1','1','1','1','1','1','1','1','1','1','1','1','1','1', '1','2','5','2','4','6','2','2', '3','2','9','5','2','4'])


df['censo_cursada_piso'] = df['censo_cursada_piso'].replace(['-','---','--','_','.','N/A','\\n','|','__','/','X','NIN','XXX','S/N','...','N','NAD','SN',',','___','S/D','*','_--','..'], ['NO', 'NO', 'NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO','NO'])
df['censo_cursada_piso'] = df['censo_cursada_piso'].replace(['0','P.B','PB-','-PB','P B','BAJ','PB.','P:B'], ['PB', 'PB', 'PB','PB','PB','PB','PB','PB'])
df['censo_cursada_piso'] = df['censo_cursada_piso'].replace(['PL','CAS','EP','Q','FDO','OO','M.A','P','PAL','FON','MAN','FRE','PID','P V','PBA','PIS','O.B', 'B','O','SI','-1','M19','86','59','DPT','M31','A','M5','F','D','80','I','340','M37','H','M 3','94','C63','M3','C','M49','MZ6','280','105','M7','53','205','92','B2','PLA','99','M65','100'], ['OTRO', 'OTRO', 'OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO', 'OTRO', 'OTRO', 'OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO', 'OTRO','OTRO','OTRO', 'OTRO', 'OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO'])
df['censo_cursada_piso'] = df['censo_piso'].replace(['P.A','P/A','PH ','-PH','FDO','OO','M.A','P','PAL','FON','MAN','FRE','PID','P V','PBA','PIS','O.B', 'B','O','SI','-1','M19','86','59','DPT','M31','A','M5','F','D','80','I','340','M37','H','M 3','94','C63','M3','C','M49','MZ6','280','105','M7','53','205','92','B2','PLA','99','M65','100'], ['PA', 'PA', 'PH','PH','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO', 'OTRO', 'OTRO', 'OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO', 'OTRO','OTRO','OTRO', 'OTRO', 'OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO','OTRO'])
df['censo_cursada_piso'] = df['censo_piso'].replace(['1B','1°','1RO','1ER','1º','PRI','-1°','1C','1 A','1A','1A','1P','P1','1R.','Nª1','2DO','5TO','2B','4TO','6TO','2°','2 A', '3º','2A','9°','5°','2º','4 A'], ['1','1','1','1','1','1','1','1','1','1','1','1','1','1', '1','2','5','2','4','6','2','2', '3','2','9','5','2','4'])

df.censo_piso.unique()

#HIST PISO DESPUES DE LIMPIAR EL CAMPO

x = df.censo_piso.unique()
y = df.censo_piso.value_counts()

plt.figure(figsize=(30,10))

plt.bar(x, y, width = 1, color = '#7B89C1')
plt.title('TIPO DE PISO DE LOS ESTUDIANTES', fontsize = 15)
# You can specify a rotation for the tick labels in degrees or with keywords.
plt.ylabel('CANTIDAD DE ESTUDIANTES', fontsize = 12)
plt.xlabel('TIPO DE PISO', fontsize = 12)
plt.xticks(x, rotation='vertical', fontsize = 12)
# Pad margins so that markers don't get clipped by the axes
plt.margins(0.1)
# Tweak spacing to prevent clipping of tick-labels
plt.subplots_adjust(bottom=0.2)
plt.show()

#EMAIL BAR PLOT BEFORE CLEANING

plt.figure(figsize=(30,10))

x = df.email.unique()
y = df.email.value_counts()

plt.bar(x, y, width = 1, color = '#7B89C1')
plt.title('CANTIDAD DE ESTUDIANTES / TIPO DE EMAIL', fontsize = 15)
plt.ylabel('CANTIDAD DE ESTUDIANTES', fontsize = 12)
plt.xlabel('EMAIL', fontsize = 12)
# You can specify a rotation for the tick labels in degrees or with keywords.
plt.xticks(x, rotation='vertical', fontsize = 12)
# Pad margins so that markers don't get clipped by the axes
plt.margins(0.1)
# Tweak spacing to prevent clipping of tick-labels
plt.subplots_adjust(bottom=0.2)
plt.show()

#CLEAN EMAILS

plt.figure(figsize=(20,10))

df.loc[df.groupby('email').email.transform('count').lt(11), 'email'] = 'otro'
df['email'] = df.email.replace('-', 'NO')

x = df.email.unique()
y = df.email.value_counts()

plt.bar(x, y, width = 1, color = '#7B89C1')
plt.title('CANTIDAD DE ESTUDIANTES / TIPO DE EMAIL', fontsize = 15)
plt.ylabel('CANTIDAD DE ESTUDIANTES', fontsize = 12)
plt.xlabel('EMAIL', fontsize = 12)
# You can specify a rotation for the tick labels in degrees or with keywords.
plt.xticks(x, rotation='vertical', fontsize = 12)
# Pad margins so that markers don't get clipped by the axes
plt.margins(0.1)
# Tweak spacing to prevent clipping of tick-labels
plt.subplots_adjust(bottom=0.2)
plt.show()

#HANDLE UNKNOWN CHARACTERS

m = df['censo_calle'].str.contains('', na=False)
df.loc[m,'censo_calle'] = '-11'

m = df['censo_cursada_calle'].str.contains('', na=False)
df.loc[m,'censo_cursada_calle'] = '-11'

m = df['censo_cursada_barrio'].str.contains('', na=False)
df.loc[m,'censo_cursada_barrio'] = '-13'

m = df['censo_barrio'].str.contains('', na=False)
df.loc[m,'censo_barrio'] = '-13'

m = df['censo_localidad_nombre'].str.contains('', na=False)
df.loc[m,'censo_localidad_nombre'] = '-19'

m = df['censo_cursada_localidad_nombre'].str.contains('', na=False)
df.loc[m,'censo_cursada_localidad_nombre'] = '-19'

# NORMALIZING POSTAL CODE

df = df.replace(r'\\N','NO', regex=True)

df['censo_cp'] = df['censo_cp'].replace(['NO','5001000'],['-5','-5'])
df['censo_cursada_cp'] = df['censo_cursada_cp'].replace(['NO','5001000'],['-5','-5'])

df.head()

# COMBINAR calle, barrio y codigo postal en direccion

df['address_cursada'] = df['censo_cursada_calle'] + ' '+ df['censo_cursada_altura'] +', ' + df['censo_cursada_barrio'] + ', ' + df['censo_cursada_localidad_nombre'].astype(str) + ', ' + df['censo_cursada_cp'].astype(str) + ', ' + 'BUENOS ARIES, ' + 'ARGENTINA'

df['address'] = df['censo_calle'] + ' ' + df['censo_altura'] + ', ' + df['censo_barrio'] + df['censo_localidad_nombre'].astype(str) + ', ' + df['censo_cp'].astype(str) + ', ' + 'BUENOS ARIES, ' + 'ARGENTINA'

df['meses_ingreso_pais'] = df['meses_ingreso_pais'].fillna(10000.0)

def convert_float(x):
    try:
        return float(x)
    except ValueError:
        return -200

df['address_cursada_duration'] = df['address_cursada_duration'].apply(convert_float).fillna(0).round(2)
df['address_distance'] = df['address_distance'].apply(convert_float).fillna(0).round(2)
df['address_cursada_distance'] = df['address_cursada_distance'].apply(convert_float).fillna(0).round(2)

df = df.fillna(-200)

# HANDLE DATATYPES

df['nacionalidad'] = df['nacionalidad'].astype(object)
df['sexo'] = df['sexo'].astype(object)
df['email'] = df['email'].astype(object)
df['censo_unido_hecho'] = df['censo_unido_hecho'].astype(object)
df['censo_situacion_padre'] = df['censo_situacion_padre'].astype(object)
df['censo_situacion_madre'] = df['censo_situacion_madre'].astype(object)
df['censo_celiaco'] = df['censo_celiaco'].astype(object)
df['censo_calle'] = df['censo_calle'].astype(object)
df['censo_piso'] = df['censo_piso'].astype(object)
df['censo_barrio'] = df['censo_barrio'].astype(object)
df['censo_cp'] = df['censo_cp'].astype(object)
df['censo_cursada_barrio'] = df['censo_cursada_barrio'].astype(object)
df['censo_cursada_piso'] = df['censo_cursada_piso'].astype(object)
df['censo_cursada_calle'] = df['censo_cursada_calle'].astype(object)
df['censo_cursada_cp'] = df['censo_cursada_cp'].astype(object)
df['censo_estado_civil'] = df['censo_estado_civil'].astype(object)
df['censo_cantidad_hijos'] = df['censo_cantidad_hijos'].astype(float)
df['censo_cantidad_familia'] = df['censo_cantidad_familia'].astype(float)
df['censo_turno_preferido'] = df['censo_turno_preferido'].astype(object)
df['censo_cobertura_salud'] = df['censo_cobertura_salud'].astype(object)
df['censo_tipo_vivienda'] = df['censo_tipo_vivienda'].astype(object)
df['censo_vive_con'] = df['censo_vive_con'].astype(object)
df['censo_localidad'] = df['censo_localidad'].astype(object)
df['censo_cursada_localidad'] = df['censo_cursada_localidad'].astype(object)
df['persona'] = df['persona'].astype(int)
df['apellido'] = df['apellido'].astype(object)
df['address'] = df['address'].astype(object)
df['address_cursada'] = df['address_cursada'].astype(object)
df['meses_ingreso_pais'] = df['meses_ingreso_pais'].astype(int)
df['censo_cursada_altura'] = df['censo_cursada_altura'].astype(object)
df['censo_altura'] = df['censo_altura'].astype(object)
df['censo_localidad_nombre'] = df['censo_localidad_nombre'].astype(object)
df['censo_cursada_localidad_nombre'] = df['censo_cursada_localidad_nombre'].astype(object)
df['address_duration'] = df['address_duration'].astype(float)
df['address_cursada_duration'] = df['address_cursada_duration'].astype(float)
df['address_distance'] = df['address_distance'].astype(float)
df['address_cursada_distance'] = df['address_cursada_distance'].astype(float)

df.dtypes

"""RENAME:
address_duration -> address_driving_time /// address_cursada_duration -> address_cursada_driving_time
"""

df.rename(columns={"address_duration": "address_driving_time(h)", "address_cursada_duration": "address_cursada_driving_time(h)"}, inplace = True)
df.rename(columns={"address_distance": "address_distance(km)", "address_cursada_distance": "address_cursada_distance(km)"}, inplace = True)

df.head(3)

"""**EXPLORATORY DATA ANALYSIS**"""

df.pivot_table(index='cant_eval_m0', aggfunc='size').plot(kind='bar', title = 'CLASS DISTRIBUTION', fontsize = 12, color = ['b','r'], figsize = (9,7), width = 0.5)

# % ABANDONO POBLACION

cant_0 = df.persona.where((df['cant_eval_m0']== 0)).notnull().sum()

cant_1 = df.persona.where((df['cant_eval_m0']== 1)).notnull().sum()

x = (cant_1/(cant_1+cant_0)).round(2)
y = (cant_0/(cant_1+cant_0)).round(2)
g = [x, y]

print('Cantidad de estudiantes: ', cant_1 + cant_0)
print('Abandonaron:     ', cant_1)
print('No Abandonaron:  ', cant_0)
print('% Abandono:      ', x)
print()

plt.figure(figsize = (9,6))
plt.title('% DE ABANDONO', fontsize = 15)
plt.pie(g, labels = g, colors = ['r','b'], radius = 1, textprops ={'fontsize': 15})
plt.show()

# ABANDONO POR MAIL UNAHUR: ES 10% MENOS 15% MENOS QUE EL % DE ABANDONO REGULAR

cant_0 = df.persona.where((df['email']== 'unahur.edu.ar') & (df['cant_eval_m0']== 0)).notnull().sum()

cant_1 = df.persona.where((df['email']== 'unahur.edu.ar') & (df['cant_eval_m0']== 1)).notnull().sum()

x = (cant_1/(cant_1+cant_0)).round(2)
y = (cant_0/(cant_1+cant_0)).round(2)
g = [x, y]

print('Poblacion total: ', cant_1 + cant_0)
print('Abandonaron:     ', cant_1)
print('No Abandonaron:  ', cant_0)
print('% Abandono:      ', x)
print()

plt.figure(figsize = (9,6))
plt.title('% DE ABANDONO MAIL UNAHUR', fontsize = 15)
plt.pie(g, labels = g, colors = ['r','b'], radius = 1, textprops ={'fontsize': 15})
plt.show()

# ABANDONO POR GMAIL: SIMILAR AL ABANDONO REGULAR

cant_0 = df.persona.where((df['email']== 'gmail.com') & (df['cant_eval_m0']== 0)).notnull().sum()

cant_1 = df.persona.where((df['email']== 'gmail.com') & (df['cant_eval_m0']== 1)).notnull().sum()

x = (cant_1/(cant_1+cant_0)).round(2)
y = (cant_0/(cant_1+cant_0)).round(2)
g = [x, y]

print('Poblacion total: ', cant_1 + cant_0)
print('Abandonaron:     ', cant_1)
print('No Abandonaron:  ', cant_0)
print('% Abandono:      ', x)
print()

plt.figure(figsize = (9,6))
plt.title('% DE ABANDONO GMAIL', fontsize = 15)
plt.pie(g, labels = g, colors = ['r','b'], radius = 1, textprops ={'fontsize': 15})
plt.show()

#ABANDONO POR HOTMAIL: mayor al abandono poblacional. Por que la gente con hotmail abandona mas?

cant_0 = df.persona.where((df['email']== 'hotmail.com') & (df['cant_eval_m0']== 0)).notnull().sum()

cant_1 = df.persona.where((df['email']== 'hotmail.com') & (df['cant_eval_m0']== 1)).notnull().sum()

x = (cant_1/(cant_1+cant_0)).round(2)
y = (cant_0/(cant_1+cant_0)).round(2)
g = [x, y]

print('Poblacion total: ', cant_1 + cant_0)
print('Abandonaron:     ', cant_1)
print('No Abandonaron:  ', cant_0)
print('% Abandono:      ', x)
print()

plt.figure(figsize = (9,6))
plt.title('% DE ABANDONO HOTMAIL', fontsize = 15)
plt.pie(g, labels = g, colors = ['r','b'], radius = 1, textprops ={'fontsize': 15})
plt.show()

#ABANDONO POR OUTLOOK: similar al the hotmail

cant_0 = df.persona.where((df['email']== 'outlook.com') & (df['cant_eval_m0']== 0)).notnull().sum()

cant_1 = df.persona.where((df['email']== 'outlook.com') & (df['cant_eval_m0']== 1)).notnull().sum()

x = (cant_1/(cant_1+cant_0)).round(2)
y = (cant_0/(cant_1+cant_0)).round(2)
g = [x, y]

print('Poblacion total: ', cant_1 + cant_0)
print('Abandonaron:     ', cant_1)
print('No Abandonaron:  ', cant_0)
print('% Abandono:      ', x)
print()

plt.figure(figsize = (9,6))
plt.title('% DE ABANDONO OUTLOOK', fontsize = 15)
plt.pie(g, labels = g, colors = ['r','b'], radius = 1, textprops ={'fontsize': 15})
plt.show()

plt.figure(figsize = (10,7))
x = ['gmail.com','outlook.com','hotmai.com','unahur.edu.ar']
y = [df.edad[df.email == 'gmail.com'].median(), df.edad[df.email == 'outlook.com'].median(), df.edad[df.email == 'hotmail.com'].median(), df.edad[df.email == 'unahur.edu.ar'].median()]
plt.bar(x,y, color = 'blue')
plt.title('EDAD MEDIA DE GENTE CON RESPECTIVO EMAIL')
plt.show()

#ABANDONO POR EDAD (MENORES DE 20)

cant_0 = df.persona.where((df['edad'] <= 20) & (df['cant_eval_m0']== 0)).notnull().sum()

cant_1 = df.persona.where((df['edad'] <= 20) & (df['cant_eval_m0']== 1)).notnull().sum()

x = (cant_1/(cant_1+cant_0)).round(2)
y = (cant_0/(cant_1+cant_0)).round(2)
g = [x, y]

print('Poblacion total: ', cant_1 + cant_0)
print('Abandonaron:     ', cant_1)
print('No Abandonaron:  ', cant_0)
print('% Abandono:      ', x)
print()

plt.figure(figsize = (7,4))
plt.title('% DE ABANDONO ESTUDIANTES MENORES DE 20', fontsize = 15)
plt.pie(g, labels = g, colors = ['r','b'], radius = 1, textprops ={'fontsize': 15})
plt.show()

#ABANDONO POR EDAD (20 - 30)

cant_0 = df.persona.where((df['edad'] > 20) & (df['edad'] < 30) & (df['cant_eval_m0']== 0)).notnull().sum()

cant_1 = df.persona.where((df['edad'] > 20) & (df['edad'] < 30) & (df['cant_eval_m0']== 1)).notnull().sum()

x = (cant_1/(cant_1+cant_0)).round(2)
y = (cant_0/(cant_1+cant_0)).round(2)
g = [x, y]

print('Poblacion total: ', cant_1 + cant_0)
print('Abandonaron:     ', cant_1)
print('No Abandonaron:  ', cant_0)
print('% Abandono:      ', x)
print()

plt.figure(figsize = (9,6))
plt.title('% DE ABANDONO ESTUDIANTES ENTRE 20 Y 30', fontsize = 15)
plt.pie(g, labels = g, colors = ['r','b'], radius = 1, textprops ={'fontsize': 15})
plt.show()

#ABANDONO POR EDAD (MAYORES DE 30)

cant_0 = df.persona.where((df['edad'] > 30) & (df['cant_eval_m0']== 0)).notnull().sum()

cant_1 = df.persona.where((df['edad'] > 30) & (df['cant_eval_m0']== 1)).notnull().sum()

x = (cant_1/(cant_1+cant_0)).round(2)
y = (cant_0/(cant_1+cant_0)).round(2)
g = [x, y]

print('Poblacion total: ', cant_1 + cant_0)
print('Abandonaron:     ', cant_1)
print('No Abandonaron:  ', cant_0)
print('% Abandono:      ', x)
print()

plt.figure(figsize = (9,6))
plt.title('% DE ABANDONO ESTUDIANTES MAYORES DE 30', fontsize = 15)
plt.pie(g, labels = g, colors = ['grey','lightgrey'], radius = 1, textprops ={'fontsize': 15})
plt.show()

"""**CORRELACION DE ATRIBUTOS CON EL TARGET**"""

df.corr()

df.head(3)

"""**ENCODING CATEGORICAL DATA**"""

# ONE HOT ENCODING: sexo, nacionalidad, email, estad civil, unido hecho, padre, madre, turno preferido, cobertura salud, tipo vivienda, vive con, celiaco, piso

for col in df:
    print(col, ': ', df[col].nunique())

# binary encoding
encoder = ce.BinaryEncoder(cols=['apellido',
                                'address_cursada','address','censo_altura','censo_cursada_altura','censo_calle','censo_cursada_calle','censo_barrio','censo_cursada_barrio'],return_df=True)


df_encoded = encoder.fit_transform(df)

#one hot encoding

encoder = ce.OneHotEncoder(cols=['sexo','nacionalidad','email','censo_estado_civil','censo_unido_hecho','censo_situacion_madre',
                                'censo_situacion_padre','censo_turno_preferido','censo_cobertura_salud','censo_tipo_vivienda','censo_vive_con','censo_celiaco',
                                'censo_piso','censo_cursada_piso','censo_cursada_localidad_nombre','censo_localidad_nombre','censo_cp',
                                 'censo_cursada_cp'],return_df=True)

df_encoded = encoder.fit_transform(df_encoded)

df_encoded.head()

"""**STANDARIZING NUMERICAL VARIABLES**"""

X = df_encoded.drop(['cant_eval_m0','fecha_actualizacion','fecha_nacimiento','fecha_ingreso_pais','censo_localidad','censo_cursada_localidad'], axis = 1)
X = X.set_index('persona')
# X = df_encoded.drop(['cant_eval_m0'], axis = 1)
y = df_encoded['cant_eval_m0']

# X_scaled = X.copy()

# from sklearn.preprocessing import StandardScaler

# scaler = StandardScaler()
# X_scaled[['edad','cant_eval_2020c1','cant_eval_2020c2','cant_eval_2021c1','meses_censo','censo_cantidad_hijos','censo_cantidad_familia',
#           'meses_ingreso_pais','address_driving_time(h)','address_cursada_driving_time(h)','address_distance(km)',
#           'address_cursada_distance(km)']] = scaler.fit_transform(X[[ 'edad','cant_eval_2020c1','cant_eval_2020c2',
#           'cant_eval_2021c1','meses_censo','censo_cantidad_hijos','censo_cantidad_familia',
#           'meses_ingreso_pais','address_driving_time(h)','address_cursada_driving_time(h)',
#           'address_distance(km)','address_cursada_distance(km)']])

# X_scaled.head()

df.to_csv('dataset.csv')
X.to_csv('X.csv')
y.to_csv('y.csv')

"""**TRAIN/TEST SPLIT**"""

def train_test(train_size):
  X_train, X_test, y_train, y_test = train_test_split(X, y, train_size = train_size)
  return X_train, X_test, y_train, y_test

"""**MODEL METRICS**"""

def metrics(clf):
  y_score = clf.predict_proba(X_test)[:,1]
  fpr, tpr, thresholds = roc_curve(y_test, y_score)
  J = tpr-fpr
  index = np.argmax(J)
  thresholdOpt = thresholds[index]
  y_pred = (clf.predict_proba(X_test)[:,1] >= thresholdOpt).astype(bool)
  print('Confusion Matrix')
  print()
  print(confusion_matrix(y_test,y_pred))
  print()
  print('ROC-AUC:             ', roc_auc_score(y_test, y_score))
  print('Balanced Accuracy:   ', balanced_accuracy_score(y_test,y_pred))

"""**ROC CURVE + OPTIMAL TRESHOLD**"""

def roc(clf):
  y_score = clf.predict_proba(X_test)[:, 1]
  fpr, tpr, thresholds = roc_curve(y_test, y_score)
  df_fpr_tpr = pd.DataFrame({'FPR':fpr, 'TPR':tpr, 'Threshold':thresholds})
  J = tpr - fpr
  index = np.argmax(J)
  thresholdOpt = round(thresholds[index], ndigits = 4)
  fprOpt = round(fpr[index], ndigits = 4)
  tprOpt = round(tpr[index], ndigits = 4)
  print('Best Threshold: ', thresholdOpt)
  print()
  plotnine.options.figure_size = (8, 4.8)
  print((
    ggplot(data = df_fpr_tpr)+
    geom_point(aes(x = 'FPR',
                  y = 'TPR'),
              size = 0.4)+
    geom_point(aes(x = fprOpt,
                  y = tprOpt),
              color = '#981220',
              size = 4)+
    geom_line(aes(x = 'FPR',
                  y = 'TPR'))+
    geom_text(aes(x = fprOpt,
                  y = tprOpt),
              label = 'Optimal threshold \n for class: {}'.format(thresholdOpt),
              nudge_x = 0.14,
              nudge_y = -0.10,
              size = 10,
              fontstyle = 'italic')+
    labs(title = 'ROC Curve')+
    xlab('False Positive Rate (FPR)')+
    ylab('True Positive Rate (TPR)')+
    theme_minimal()
  ))

"""**FEATURE IMPORTANCE**"""

def fi(clf):

  import warnings
  warnings.filterwarnings("ignore")

  sort = clf.feature_importances_.argsort()[::-1]
  fi = clf.feature_importances_[sort]
  cols = X.columns[sort]

  fidf = pd.DataFrame()

  fidf['attribute'] = cols
  fidf['importance'] = fi

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_cp'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_cp'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_cursada_cp'))] = 'censo_cursada_cp'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cp'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cp'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_cp'))] = 'censo_cp'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_turno_preferido'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_turno_preferido'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_turno_preferido'))] = 'censo_turno_preferido'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_estado_civil'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_estado_civil'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_estado_civil'))] = 'censo_estado_civil'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_localidad_nombre'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_localidad_nombre'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_cursada_localidad_nombre'))] = 'censo_cursada_localidad_nombre'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cobertura_salud'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cobertura_salud'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_cobertura_salud'))] = 'censo_cobertura_salud'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_localidad_nombre'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_localidad_nombre'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_localidad_nombre'))] = 'censo_localidad_nombre'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_altura'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_altura'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_altura'))] = 'censo_altura'

  fidf['importance'].loc[(fidf['attribute'].str.contains('email'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('email'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('email'))] = 'email'

  fidf['importance'].loc[(fidf['attribute'].str.contains('address'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('address'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('address'))] = 'address'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_unido_hecho'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_unido_hecho'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_unido_hecho'))] = 'censo_unido_hecho'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_barrio'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_barrio'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_barrio'))] = 'censo_barrio'

  fidf['importance'].loc[(fidf['attribute'].str.contains('address'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('address'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('address'))] = 'address'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_tipo_vivienda'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_tipo_vivienda'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_tipo_vivienda'))] = 'censo_tipo_vivienda'

  fidf['importance'].loc[(fidf['attribute'].str.contains('apellido'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('apellido'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('apellido'))] = 'apellido'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_celiaco'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_celiaco'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_celiaco'))] = 'censo_celiaco'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_calle'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_calle'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_calle'))] = 'censo_calle'

  fidf['importance'].loc[(fidf['attribute'].str.contains('sexo'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('sexo'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('sexo'))] = 'sexo'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_piso'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_piso'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_cursada_piso'))] = 'censo_cursada_piso'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_barrio'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_barrio'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_cursada_barrio'))] = 'censo_cursada_barrio'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_altura'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_altura'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_cursada_altura'))] = 'censo_cursada_altura'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_calle'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_cursada_calle'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_cursada_calle'))] = 'censo_cursada_calle'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_vive_con'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_vive_con'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_vive_con'))] = 'censo_vive_con'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_situacion_madre'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_situacion_madre'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_situacion_madre'))] = 'censo_situacion_madre'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_situacion_padre'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_situacion_padre'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_situacion_padre'))] = 'censo_situacion_padre'

  fidf['importance'].loc[(fidf['attribute'].str.contains('censo_piso'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('censo_piso'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('censo_piso'))] = 'censo_piso'

  fidf['importance'].loc[(fidf['attribute'].str.contains('nacionalidad'))] = fidf['importance'].loc[(fidf['attribute'].str.contains('nacionalidad'))].mean()
  fidf['attribute'].loc[(fidf['attribute'].str.contains('nacionalidad'))] = 'nacionalidad'

  fidf = fidf.drop_duplicates(subset=['attribute'])

  fidf = fidf.sort_values(by = 'importance', ascending=False)

  fidf = fidf[:20]

  fig = plt.figure()
  fig.set_size_inches(10, 12)
  plt.title('Mean Feature Importance')
  plt.xlabel('Feature Importance')
  plt.barh(fidf.attribute[::-1], fidf.importance[::-1], color = 'grey')

"""**BASELINE MODEL (PREDICT ALL DROPOUTS)**"""

# if we were to predict all dropouts, we would get a 50% balanced accuracy

X_train, X_test, y_train, y_test = train_test(0.70)
y_pred = [1]*9354

print('Confusion Matrix')
print()
print(confusion_matrix(y_test,y_pred))
print()
print('Balanced Accuracy: ', balanced_accuracy_score(y_test,y_pred))

"""**DECISION TREE**"""

def build_tree():
  clf = DecisionTreeClassifier(criterion='entropy', max_depth = 9, min_samples_split=5,min_samples_leaf=3)
  clf.fit(X_train, y_train)
  return clf

X_train, X_test, y_train, y_test = train_test(0.7)
clf = build_tree()
fig = roc(clf)
metrics(clf)

fi(clf)

"""**LOGISTIC REGRESSION**"""

# X_train, X_test, y_train, y_test = train_test(0.75)

# # X_train = X_train[['meses_censo','cant_eval_2021c1','cant_eval_2020c2','cant_eval_2020c1','edad']]
# # X_test = X_test[['meses_censo','cant_eval_2021c1','cant_eval_2020c2','cant_eval_2020c1','edad']]

# clf = LogisticRegression(class_weight = 'balanced', max_iter = 1000)
# clf = clf.fit(X_train, y_train)

# roc(clf)
# metrics(clf)

"""**SVM Model**"""

# X_train, X_test, y_train, y_test = train_test(0.75)

# X_train = X_train[['meses_censo','cant_eval_2021c1','cant_eval_2020c2','cant_eval_2020c1','edad','censo_cantidad_hijos','censo_cantidad_familia','address_driving_time(h)','address_cursada_driving_time(h)','address_distance(km)','address_cursada_distance(km)','sexo_1','sexo_2','sexo_3']]
# X_test = X_test[['meses_censo','cant_eval_2021c1','cant_eval_2020c2','cant_eval_2020c1','edad','censo_cantidad_hijos','censo_cantidad_familia','address_driving_time(h)','address_cursada_driving_time(h)','address_distance(km)','address_cursada_distance(km)','sexo_1','sexo_2','sexo_3']]

# from sklearn.svm import SVC
# clf = SVC(probability = True)
# clf.fit(X_train, y_train)

# roc(clf)
# metrics(clf)

"""**RANDOM FOREST**"""

# from sklearn.ensemble import RandomForestClassifier

# clf = RandomForestClassifier(criterion = 'entropy', n_estimators = 500)
# clf.fit(X_train, y_train)
# roc(clf)
# metrics(clf)

"""**XGBOOST**"""

from sklearn.model_selection import RandomizedSearchCV

def xgb_ht():

  import xgboost as xgb

  params = {
      'max_depth': np.arange(1,11,2),
      'learning_rate': np.arange(0.01,1,0.1),
      'subsample': np.arange(0.5,1,0.1),
      'colsample_bytree': np.arange(0.4, 1.0, 0.1),
      'colsample_bylevel': np.arange(0.4, 1.0, 0.1),
      'gamma': np.arange(0.1,1,0.05),
      'reg_lambda': np.arange(1,9,2),
      'scale_pos_weight': np.arange(1,9,2),
      'n_estimators': np.arange(200,500,2)
    }

  xgb = xgb.XGBClassifier(objective = 'binary:logistic', seed=42, early_stopping_rounds = 10, eval_metric = 'auc')

  clf = RandomizedSearchCV( estimator = xgb,
                            param_distributions = params,
                            scoring='roc_auc',
                            verbose=False,
                            n_iter = 50)

  clf.fit(X_train,
          y_train,
          eval_set=[(X_test,y_test)],
          verbose=False)

  print(clf.best_params_)

def build_xgb():

  import xgboost as xgb

  clf_xgb = xgb.XGBClassifier(seed = 42,
                              objective = 'binary:logistic',
                              gamma=0.5,
                              learning_rate =0.2,
                              max_depth=9,
                              reg_lambda=5,
                              n_estimators = 256,
                              scale_pos_weight=3,
                              subsample=0.6,
                              colsample_bytree=0.7,
                              colsample_bylevel =0.6,
                              eval_metric='auc',
                              early_stopping_rounds=10)


  clf_xgb.fit(X_train,
              y_train,
              verbose=False,
              eval_set=[(X_test,y_test)])

  return clf_xgb

"""**HYPERPARAMETER TUNING XGB**"""

# xgb_ht()

"""**MODEL SUMMARY**"""

X_train, X_test, y_train, y_test = train_test(0.75)
xgb = build_xgb()
roc(xgb)
metrics(xgb)

"""**EXPLORING XGB FI**"""

from xgboost import plot_importance
plot_importance(xgb, max_num_features = 10, importance_type = 'weight')

plot_importance(xgb, max_num_features = 10, importance_type = 'cover')

plot_importance(xgb, max_num_features = 10, importance_type = 'gain')

fi(xgb)

"""**GRADIENT DESCENT ALGORITHM**"""

# gradient optimization
# bayesian optimization
# comparar los modelos (xgboost, arbol, regresion logistica, svm, random forest)

import random
def initialize(dim):
  b=random.random()
  theta=np.random.rand(dim)
  return b,theta

b,theta=initialize(3)
print("Bias: ",b, "Weights: ",theta)

"""**MULTIDIMENSIONAL PLOTS**"""

# import pandas as pd
# import plotly
# import plotly.graph_objs as go



# #Set marker properties
# markercolor = df_encoded['cant_eval_m0']

# #Make Plotly figure
# fig1 = go.Scatter3d(x=df_encoded['cant_eval_2021c1'],
#                     y=df_encoded['cant_eval_2020c2'],
#                     z=df_encoded['cant_eval_2020c1'],
#                     marker=dict(color=markercolor,
#                                 opacity=1,
#                                 reversescale=True,
#                                 colorscale='Blues',
#                                 size=5),
#                     line=dict (width=0.02),
#                     mode='markers')

# #Make Plot.ly Layout
# mylayout = go.Layout(scene=dict(xaxis=dict( title="curb-weight"),
#                                 yaxis=dict( title="horsepower"),
#                                 zaxis=dict(title="price")),)

# #Plot and save html
# plotly.offline.plot({"data": [fig1],
#                      "layout": mylayout},
#                      auto_open=True,
#                      filename=("4DPlot.html"))

def email_dropout():
  fig,axs = plt.subplots(2,2, figsize=(10,7))

  fig.suptitle('Abandono por Email', fontsize = 20)

  cant_0 = df.persona.where((df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[0,0].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[0,0].set_title('Abandono Poblacional', fontsize = 15)

  cant_0 = df.persona.where((df['email']== 'gmail.com') & (df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['email']== 'gmail.com') & (df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[0,1].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[0,1].set_title('Abandono Gmail', fontsize = 15)

  cant_0 = df.persona.where((df['email']== 'hotmail.com') & (df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['email']== 'hotmail.com') & (df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[1,0].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[1,0].set_title('Abandono Hotmail', fontsize = 15)

  cant_0 = df.persona.where((df['email']== 'unahur.edu.ar') & (df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['email']== 'unahur.edu.ar') & (df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[1,1].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[1,1].set_title('Abandono Mail UNAHUR', fontsize = 15)

email_dropout()

def gender_dropout():
  fig,axs = plt.subplots(3, figsize=(10,7))

  fig.suptitle('Abandono por Sexo', fontsize = 20)

  cant_0 = df.persona.where((df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[0].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[0].set_title('Abandono Poblacional', fontsize = 15)

  cant_0 = df.persona.where((df['sexo'] =='M') & (df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['sexo'] =='M') & (df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[1].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[1].set_title('Abandono Hombres', fontsize = 15)

  cant_0 = df.persona.where((df['sexo'] =='F') & (df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['sexo'] =='F') & (df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[2].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[2].set_title('Abandono Mujeres', fontsize = 15)


gender_dropout()

def age_dropout():
  fig,axs = plt.subplots(2,2, figsize=(10,7))

  fig.suptitle('Abandono por Edad', fontsize = 20)

  cant_0 = df.persona.where((df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[0,0].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[0,0].set_title('Abandono Poblacional', fontsize = 15)

  cant_0 = df.persona.where((df['edad'] >= 18) & (df['edad'] <= 25) & (df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['edad'] >= 18) & (df['edad'] <= 25) & (df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[0,1].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[0,1].set_title('Abandono 18-25', fontsize = 15)

  cant_0 = df.persona.where((df['edad'] > 25) & (df['edad'] < 40) & (df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['edad'] > 25) & (df['edad'] < 40) & (df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[1,0].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[1,0].set_title('Abandono 25-40', fontsize = 15)

  cant_0 = df.persona.where((df['edad'] > 40) & (df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['edad'] > 40) & (df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[1,1].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[1,1].set_title('Abandono 40+', fontsize = 15)

age_dropout()

df.persona.where((df['censo_turno_preferido'] == 1) | (df['censo_turno_preferido']== 4) | (df['censo_turno_preferido']== 5)).notnull().sum()

m1 = df.persona.where((df['sexo'] == 'M') & (df['cant_eval_m0']== 1)).notnull().sum()
m0 = df.persona.where((df['sexo'] == 'M') & (df['cant_eval_m0']== 0)).notnull().sum()
f1 = df.persona.where((df['sexo'] == 'F') & (df['cant_eval_m0']== 1)).notnull().sum()
f0 = df.persona.where((df['sexo'] == 'F') & (df['cant_eval_m0']== 0)).notnull().sum()

print('m0: ', m0)
print('m1: ', m1)
print('f0: ', f0)
print('f1: ', f1)

def edad():
  x = ['Poblacional','18-33','33-48','48-63','63-78','78+']

  y0 = df.persona.where((df['cant_eval_m0'] == 1)).notnull().sum() / df.persona.notnull().sum()
  y1 = df.persona.where((df['edad'] >= 18) & (df['edad'] < 33) & (df['cant_eval_m0'] == 1)).notnull().sum() / df.persona.where((df['edad'] >= 18) & (df['edad'] < 33)).notnull().sum()
  y2 = df.persona.where((df['edad'] >= 33) & (df['edad'] < 48) & (df['cant_eval_m0'] == 1)).notnull().sum() / df.persona.where((df['edad'] >= 33) & (df['edad'] < 48)).notnull().sum()
  y3 = df.persona.where((df['edad'] >= 48) & (df['edad'] < 63) & (df['cant_eval_m0'] == 1)).notnull().sum() / df.persona.where((df['edad'] >= 48) & (df['edad'] < 63)).notnull().sum()
  y4 = df.persona.where((df['edad'] >= 63) & (df['edad'] < 78) & (df['cant_eval_m0'] == 1)).notnull().sum() / df.persona.where((df['edad'] >= 63) & (df['edad'] < 78)).notnull().sum()
  y5 = df.persona.where((df['edad'] >= 78) & (df['edad'] < 99) & (df['cant_eval_m0'] == 1)).notnull().sum() / df.persona.where((df['edad'] >= 78) & (df['edad'] < 99)).notnull().sum()

  y = [y0.round(2),y1.round(2),y2.round(2),y3.round(2),y4.round(2),y5.round(2)]

  a = np.arange(len(x)) # the label locations
  width = 0.35 # the width of the bars

  fig, ax = plt.subplots(figsize = (10,7))

  ax.set_ylabel('% Abandono')
  ax.set_title('Edad')
  ax.set_xticks(a)
  ax.set_xticklabels(x)

  pps = ax.bar(a - width/2, y, width, label='%', color = 'grey')
  for p in pps:
    height = p.get_height()
    ax.annotate('{}'.format(height),
        xy=(p.get_x() + p.get_width() / 2, height),
        xytext=(0, 3), # 3 points vertical offset
        textcoords="offset points",
        ha='center', va='bottom')

  plt.show()

edad()

def hijos_dropout():

  df2 = df.copy()
  df2[df2['censo_cantidad_hijos'] >= 2] = 2

  fig,axs = plt.subplots(2,2, figsize=(10,7))

  fig.suptitle('Abandono por Cantidad de Hijos', fontsize = 20)

  cant_0 = df.persona.where((df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[0,0].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[0,0].set_title('Abandono Poblacional', fontsize = 15)

  cant_0 = df.persona.where((df['censo_cantidad_hijos'] == 0) & (df['cant_eval_m0'] == 0)).notnull().sum()

  cant_1 = df.persona.where((df['censo_cantidad_hijos'] == 0) & (df['cant_eval_m0'] == 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[0,1].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[0,1].set_title('Abandono 0 Hijos', fontsize = 15)

  cant_0 = df.persona.where((df['censo_cantidad_hijos'] == 1) & (df['cant_eval_m0'] == 0)).notnull().sum()

  cant_1 = df.persona.where((df['censo_cantidad_hijos'] == 1) & (df['cant_eval_m0'] == 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[1,0].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[1,0].set_title('Abandono 1 Hijo', fontsize = 15)

  cant_0 = df.persona.where((df2['censo_cantidad_hijos'] == 2) & (df['cant_eval_m0'] == 0)).notnull().sum()

  cant_1 = df.persona.where((df2['censo_cantidad_hijos'] == 2) & (df['cant_eval_m0'] == 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[1,1].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[1,1].set_title('Abandono 2+ Hijos', fontsize = 15)

hijos_dropout()

def hijos():

  x = ['Poblacional','0','1','2','3+']

  y0 = df.persona.where((df['cant_eval_m0'] == 1)).notnull().sum() / df.persona.notnull().sum()
  y5 = df.persona.where((df['censo_cantidad_hijos'] == 0) & (df['cant_eval_m0'] == 1)).notnull().sum() / df.persona[df['censo_cantidad_hijos'] == 0].notnull().sum()
  y1 = df.persona.where((df['censo_cantidad_hijos'] == 1) & (df['cant_eval_m0'] == 1)).notnull().sum() / df.persona[df['censo_cantidad_hijos'] == 1].notnull().sum()
  y2 = df.persona.where((df['censo_cantidad_hijos'] == 2) & (df['cant_eval_m0'] == 1)).notnull().sum() / df.persona[df['censo_cantidad_hijos'] == 2].notnull().sum()
  y3 = df.persona.where((df['censo_cantidad_hijos'] == 3) & (df['cant_eval_m0'] == 1)).notnull().sum() / df.persona[df['censo_cantidad_hijos'] == 3].notnull().sum()



  y = [y0.round(2),y5.round(2),y1.round(2),y2.round(2),y3.round(2)]

  a = np.arange(len(x)) # the label locations
  width = 0.35 # the width of the bars

  fig, ax = plt.subplots(figsize = (10,7))

  ax.set_ylabel('% Abandono')
  ax.set_title('Cantidad de Hijos')
  ax.set_xticks(a)
  ax.set_xticklabels(x)

  pps = ax.bar(a - width/2, y, width, label='%', color = 'grey')
  for p in pps:
    height = p.get_height()
    ax.annotate('{}'.format(height),
        xy=(p.get_x() + p.get_width() / 2, height),
        xytext=(0, 3), # 3 points vertical offset
        textcoords="offset points",
        ha='center', va='bottom')

  plt.show()

hijos()

def turno_dropout():

  import warnings
  warnings.filterwarnings("ignore")

  df2 = df.copy()

  df2['censo_turno_preferido'][(df2['censo_turno_preferido'] == 4) | (df2['censo_turno_preferido'] == 5)] = 1
  df2['censo_turno_preferido'][(df2['censo_turno_preferido'] == 6) | (df2['censo_turno_preferido'] == 7)] = 2
  df2['censo_turno_preferido'][(df2['censo_turno_preferido'] == 8) | (df2['censo_turno_preferido'] == 9)] = 3

  fig,axs = plt.subplots(2,2, figsize=(10,7))

  fig.suptitle('Abandono por Turno', fontsize = 20)

  cant_0 = df.persona.where((df['cant_eval_m0']== 0)).notnull().sum()

  cant_1 = df.persona.where((df['cant_eval_m0']== 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[0,0].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[0,0].set_title('Abandono Poblacional', fontsize = 15)

  cant_0 = df2.persona.where((df2['censo_turno_preferido'] == 1) & (df2['cant_eval_m0'] == 0)).notnull().sum()

  cant_1 = df2.persona.where((df2['censo_turno_preferido'] == 1) & (df2['cant_eval_m0'] == 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[0,1].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[0,1].set_title('Abandono Turno AM', fontsize = 15)

  cant_0 = df2.persona.where((df2['censo_turno_preferido'] == 2) & (df2['cant_eval_m0'] == 0)).notnull().sum()

  cant_1 = df2.persona.where((df2['censo_turno_preferido'] == 2) & (df2['cant_eval_m0'] == 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[1,0].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[1,0].set_title('Abandono Turno Tarde', fontsize = 15)

  cant_0 = df2.persona.where((df2['censo_turno_preferido'] == 3) & (df2['cant_eval_m0'] == 0)).notnull().sum()
  cant_1 = df2.persona.where((df2['censo_turno_preferido'] == 3) & (df2['cant_eval_m0'] == 1)).notnull().sum()

  x = (cant_1/(cant_1+cant_0)).round(2)
  y = (cant_0/(cant_1+cant_0)).round(2)
  g = [x, y]

  axs[1,1].pie(g, labels = g, colors =['grey','lightgrey'] )
  axs[1,1].set_title('Abandono Turno Noche', fontsize = 15)

turno_dropout()

df['censo_turno_preferido'][(df['censo_turno_preferido'] == 4) | (df['censo_turno_preferido'] == 5)] = 1
  df['censo_turno_preferido'][(df['censo_turno_preferido'] == 6) | (df['censo_turno_preferido'] == 7)] = 2
  df['censo_turno_preferido'][(df['censo_turno_preferido'] == 8) | (df['censo_turno_preferido'] == 9)] = 3

  df.censo_turno_preferido.value_counts()

"""**EXPLORING SHAP LIBRARY (INTERPRETABLE MACHINE LEARNING)**"""

df = df.set_index('persona')

import shap

explainer = shap.TreeExplainer(xgb, data = X_test, model_output='probability')
shap_values = explainer.shap_values(X_test)

X_test_2 = X_test.copy()
X_test_2['dropout_proba'] = xgb.predict_proba(X_test)[:,1].round(2)
output = X_test_2[['dropout_proba']].loc[X_test_2.dropout_proba >= .90]
output['apellido'] = df['apellido'].loc[list(output.index.values)]
output.sort_values(by='dropout_proba',ascending = False).head(10)

#Global importance on predictions
fig = plt.figure()
shap.summary_plot(shap_values, X_test, show = False, plot_type = 'violin')
plt.gcf().set_size_inches(15,7)
plt.show()

def force_plot(i):
  shap.initjs()
  p = shap.force_plot(explainer.expected_value, shap_values[list(X_test.index.values).index(i)], features=X_test.loc[i], feature_names=X_test.columns)
  return p

force_plot(18787)

import pickle
filename = 'xgb_model.sav'
pickle.dump(xgb, open(filename, 'wb'))